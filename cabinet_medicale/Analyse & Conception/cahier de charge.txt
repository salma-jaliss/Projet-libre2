1
Cahier des Charges du Projet de Gestion
d’un Cabinet Médical
Ennaji Fatima Zohra, Ourdou Amal, Karoum Bouchra, Hafidi Imad
Octobre 08, 2025
1. Introduction
Ce projet a pour objectif de développer un système complet de gestion d’un cabinet médical,
permettant d’administrer efficacement les patients, les médecins, les rendez-vous, les
ordonnances et la facturation. Le système sera développé en utilisant les technologies Java Spring
Boot pour le backend et Angular pour le frontend, et une base de données relationnelle. Les
étudiants devront modéliser, implémenter, tester et documenter le système.
2. Objectif du Projet
L’objectif principal de ce projet est de permettre aux étudiants de mettre en pratique l’ensemble
des compétences acquises en développement logiciel, en architecture logicielle et en tests de
qualité dans un contexte réel de gestion d’un système de gestion centralisée pour un cabinet
médical. Cette application permettra de gérer les tâches réalisées par les médecins, la secrétaire et
l’administrateur, tout en assurant la sécurité et la traçabilité des données médicales.
2.1. Développement des Compétences Techniques
Ce projet vise consolider les compétences techniques des étudiants à travers les activités à
suivantes :
• Conception et Modélisation : Apprendre à interpréter un diagramme de classes UML
pour modéliser les entités et leurs relations dans un projet de gestion d’un Cabinet
Médicale. Cette étape est essentielle pour structurer le code de manière organisée. En
adoptant une architecture de micro-services, chaque entité peut être développée comme
un service distinct, facilitant la maintenance et l’évolution du code sans impacter
l’ensemble du système.
• Programmation Backend : Utiliser Java et Spring Boot pour développer des services
backend robustes. Chacun correspondant à une fonctionnalité ou un domaine spécifique
de l’application. Les étudiants implémenteront des fonctionnalités CRUD pour chaque
micro-service, géreront les relations entre entités et manipuleront une base de données
relationnelle (MySQL ou PostgreSQL). L’accent sera mis sur la sécurité des données,
chaque service étant conçu pour protéger ses propres accès et données, garantissant ainsi
une robustesse accrue.
2
• Programmation Frontend : Développer une interface utilisateur intuitive et réactive
avec Angular. Les étudiants apprendront à construire des composants réutilisables, gérer
les états de l’application, et assurer une communication fluide avec le backend via des
appels API RESTful.
• Intégration et Déploiement : Découvrir comment intégrer les différents composants du
système pour créer une application cohérente et fonctionnelle. Ils devront également
préparer l’application pour le déploiement sur un environnement de production, en
configurant le serveur et en gérant les dépendances logicielles. Cette phase inclura des
pratiques de déploiement continu, essentielles pour gérer efficacement des architectures
basées sur les micro-services.
2.2. Développement des Compétences en Tests
Le projet inclut des exigences strictes en matière de tests, qui visent à développer chez les
étudiants une compréhension approfondie des différentes méthodes de test, leur importance, et
leur mise en œuvre pratique :
• Tests Unitaires avec JUnit et Mockito : Les étudiants doivent écrire des tests unitaires
pour chaque composant du backend afin de valider le comportement attendu des
méthodes individuelles. Ils apprendront à créer des mocks avec Mockito pour isoler les
composants et tester leur logique indépendamment des autres parties du système.
• Tests Frontend avec Jest : Pour garantir que l’interface utilisateur fonctionne correctement, les étudiants devront écrire des tests pour chaque composant Angular. Cela inclut
la vérification des rendus, des états internes, et des interactions utilisateur. L’accent sera
mis sur la validation des fonctionnalités du frontend de manière indépendante du
backend.
• Tests de Performance avec JMeter : Les étudiants devront mettre en place des
scénarios de tests de performance pour évaluer la capacité de l’application à gérer des
charges importantes. Ils apprendront à identifier les goulets d’étranglement et à analyser
les résultats pour proposer des optimisations.
• Tests Automatisés avec Selenium : En utilisant Selenium, les étudiants écriront des tests
de bout en bout qui simuleront les parcours utilisateurs sur l’application complète. Ces
tests valideront que toutes les fonctionnalités intégrées fonctionnent correctement du
point de vue de l’utilisateur final.
2.3. Développement des Compétences en Gestion de Projet
Outre les compétences techniques, le projet vise à développer des compétences en gestion de
projet et en collaboration :
• Méthode Scrum : Le projet doit être gérer par la méthode Scrum. Les sprints doivent
êtrre défini ainsi que leur backLog avant chaque itération.
• Gestion du Temps et des Tâches : Les étudiants devront gérer le temps imparti pour
chaque tâche, respecter les échéances et organiser leur travail de manière efficace.
3
• Documentation : Produire une documentation complète et claire sur le code,
l’architecture, les tests, et les étapes d’installation et de déploiement. Cette documentation
est essentielle pour assurer la maintenabilité du projet.
• Collaboration en équipe : Travailler en groupe pour simuler un environnement de
travail réel, utiliser des outils de versionnage comme Git pour gérer le code source, et
assurer une communication fluide entre les membres de l’équipe.
2.4. Synthèse des Compétences de Développement et de Test
Le projet se veut un exercice global combinant toutes les compétences de développement et de
test. Il ne s’agit pas seulement de produire du code fonctionnel, mais de garantir que ce code est
de haute qualité, fiable, maintenable et performant. Les étudiants sont invités à :
• Appliquer une Approche Agile : Adopter des itérations courtes avec des feedbacks
réguliers pour améliorer en continu le système.
• Écrire du Code Propre : Respecter les bonnes pratiques de développement, telles
que le respect des conventions de nommage, l’écriture de code lisible et modulaire, et
la gestion efficace des exceptions.
• Mettre en Place un Pipeline de Tests Automatisés : Intégrer les tests automatisés
dans le cycle de développement pour détecter rapidement les régressions et garantir
la stabilité du système au fur et à mesure de son évolution.
2.5. Évaluation de la Qualité Globale du Système
Enfin, le projet évalue la capacité des étudiants à livrer un système complet qui répond aux
exigences fonctionnelles et non fonctionnelles, tout en respectant des standards de qualité élevés :
• Code Propre et Lisible : Le code doit respecter les conventions de nommage, être
bien structuré, et contenir des commentaires explicatifs pour la compréhension.
• Architecture Modulaire : Le code doit être organisé de manière à faciliter
l’extension et la maintenance, en utilisant des principes de POO (programmation
orientée objet) et des designs patterns si approprié.
• Documentation du Code : Chaque classe, méthode et module doit être documenté
pour expliquer son rôle et son fonctionnement.
• Pas d’Erreurs ou d’Avertissements : Le code doit être exempt d’erreurs et
d’avertissements lors de la compilation.
Les livrables devront être évalués sur leur fonctionnalité, leur performance, leur documentation,
et leur capacité à passer avec succès l’ensemble des tests écrits.
3. Description du Projet
Le système de gestion de cabinet médical repose sur une architecture modulaire permettant de
gérer : les rendez-vous, les dossiers médicaux, les ordonnances, la facturation, et les utilisateurs
(médecins, secrétaires).
4
3.1. Architecture Générale du Système
Le système est conçu selon une architecture multi-couches qui sépare la logique métier, la
présentation, et la gestion des données :
• Couche de Présentation : Interface utilisateur développée avec Angular, permettant
une interaction intuitive et dynamique avec le système.
• Couche Métier : Implémentée avec Spring Boot, cette couche contient la logique
métier, les règles de gestion, et les services qui orchestrent les différentes
fonctionnalités du système. Nous vous invitons à implémenter le back end sous forme
de micro services.
• Couche de Persistance : Utilise une base de données relationnelle (MySQL ou
PostgreSQL) pour stocker de manière sécurisée toutes les données.
• API REST : Le système utilise des API RESTful pour permettre la communication
entre le frontend et le backend, garantissant une séparation claire des responsabilités
et une évolutivité accrue.
3.2. Entités Principales du Système
Les entités principales du système sont :
• Cabinet: informations sur le cabinet
o id : Identifiant unique du cabinet.
o logo : Logo du cabinet pour une identification visuelle.
o nom : Nom du cabinet
o specialite : Généraliste, Ophtalmologue, etc.
o adresse : Adresse du cabinet
o tel : numéro de téléphone du cabinet
• Utilisateur : médecins, secrétaires, administrateur.
o login : Utilisée comme identifiant de connexion.
o pwd : Mot de passe de connexion à l’application
o nom : Nom de l’utilisateur
o prenom : Prénom de l’utilisateur
o numTel : Numéro de téléphone de l’utilisateur.
o signature : Signature numérique ou image de la signature réservée au médecin.
o role : Rôle de l’utilisateur (Médecin, secrétaire, administrateur), définissant ses
droits d’accès au système.
• Patient : données personnelles du patient.
o id : Identifiant unique du patient.
o cin : Carte d’Identité Nationale
o nom : Nom du patient.
o prenom : Prénom du patient
o dateNaissance : Date de naissance du patient
5
o sexe : Attribut indiquant le sexe du patient
o numTel : Numéro de téléphone pour contacts
o typemutuelle : Type de la mutuelle
• Rendez-vous : date, heure, motif, statut (confirmé, annulé, terminé).
o idRendezVous : Identifiant unique
o dateRdv : Date du rendez-vous
o heureRdv : Heure du rendez-vous
o motif : Motif de la visite (consultation ou contrôle)
o statut : (Confirmé, Annulé, En attente)
o notes : Remarques éventuelles (si disponible)
• Dossier Médical
o idDossier : Identifiant unique
o antMedicaux :Antécédents médicaux
o antChirug : Antécédents chirurgicaux
o allergies : Allergies
o traitement : Traitements en cours
o habitudes : (tabac, alimentation, sommeil, etc.)
o historiqueConsultations : Liste des consultations
o documentsMedicaux : Fichiers joints (analyses, radios, bilans, etc.)
o dateCreation : Date d’ouverture du dossier
• Consultation : compte rendu médical associé à un rendez-vous.
o idConsultation : Identifiant de la consultation
o type : Type de la consultation (consultation ou contrôle)
o dateConsultation : Date de la consultation
o examenClinique : Désigne l’examen physique direct réalisé par le médecin
(Température, tension artérielle, rythme cardiaque, observation d’une lésion,
d’une inflammation, etc.)
o examenSupplementaire : Analyse sanguine, urinaire, ECG, radiographie, IRM,
scanner, échographie.
o diagnostic : Diagnostic et conclusion médicale
o traitement : Médicament prescrits
o observations : Notes du médecin (si nécessaire)
• Facture : informations de paiement, montant, assurance, statut de règlement
o idFacture : Identifiant unique
o montant : Montant total
o modePaiement : Espèces, carte, assurance
6
4. Technologies Utilisées
• Backend : Java Spring Boot (microservices, sécurité, API REST).
• Frontend : Angular (interface utilisateur réactive et intuitive).
• Base de données : MySQL / PostgreSQL.
• Tests : JUnit, Mockito, Jest, Selenium, JMeter.
• CI/CD : Jenkins, Docker, GitHub.
• Documentation et gestion : Jira, Confluence.
5. Fonctionnalités à Implémenter
• Secrétaire :
o Gestion des Patients : enregistrement, modification des informations des
patients, suppression du patient et recherche d’un patient par CIN et par nom.
o Gestion des Rendez-vous : prise, modification, annulation d’un rendez-vous,
afficher la liste des rendez-vous de la journée en cours et d’une journée
déterminée.
o Gestion de la Facturation : Entrer le montant à payer, validation du paiement,
impression des factures.
o Gestion de la liste d’attente des patients : Ajouter un patient à la liste d’attente,
envoyer le dossier complet du patient en tête de liste au médecin pour qu’il
puisse accéder aux informations personnelles du patient, son dossier médicale,
l’historique des consultations, etc. pour démarrer la consultation.
• Médecin :
o Recherche des Patients par CIN et par nom.
o Consultation du profil du patient : en cours (rechercher et lancer par le
secrétaire ou par lui-même) pour qu’il puisse accéder à son dossier médicale,
historique des consultations….
o Gestion des Consultations : ajouter une consultation (saisie des diagnostics,
prescriptions, etc.), supprimer et modifier une consultation.
o Impression de l’ordonnance signé automatiquement : deux types
d’ordonnance (Ordonnance des médicaments et Ordonnance des examens
supplémentaire).
o Gestion du dossier médical du patient : remplissage et modification du dossier
médicale des patients.
o Consulter le dashboard : statistiques relatives au cabinet.
• Administrateur :
o Gestion des cabinets : Créer, modifier et supprimer les cabinets médicaux et les
comptes associés des utilisateurs à chaque cabinet, activer ou désactiver le
service auprès des cabinets.
7
o Gestion des listes des médicaments : Intégrer automatiquement la liste des
médicaments pour que le médecin puisse bénéficier de l’autocomplétions lors de
la saisie des ordonnances.
o Consulter le dashboard : statistiques relatives à l’application.
• Sécurité et Gestion des Accès : rôles et permissions (médecin, administrateur,
secrétaire).
• Intégration des notifications : Notifier l’administrateur de l’approche de l’épuisement
du service d’un cabinet médicale, Notifier médecin de la réception des informations du
patient suivant.
• Chatboot : pour que le patient puisse prendre un rendez-vous et avoir une idée sur la
disponibilité des créneaux libres d’un cabinet.
6. Tests à Réaliser
Des tests unitaires, d’intégration, de performance et de bout en bout seront réalisés pour
assurer la qualité du système. Les outils utilisés incluront JUnit, Mockito, Jest, Selenium et
JMeter. Les tests doivent être intégrés de manière continue dans le cycle de développement pour
détecter rapidement les anomalies et garantir une qualité constante du système.
6.1. Outils Complémentaires
• SonarQube : Pour analyser la qualité du code et assurer le respect des bonnes
pratiques de développement.
• Jenkins : Pour l’intégration continue, permettant l’automatisation de l’exécution
des tests à chaque changement de code.
6.2. Stratégie d’Amélioration
• Mettre en place des revues régulières des tests pour identifier les tests obsolètes
ou manquants.
• Évaluer les rapports de couverture de test pour cibler les zones non couvertes.
• Prioriser l’ajout de tests pour les fonctionnalités critiques et les zones de code
modifiées fréquemment.
7. Livrables
• Code source complet du projet (frontend, backend, scripts de base de données,
configuration de sécurité et fichiers de configuration).
• Documentation technique et utilisateur.
• Rapports de tests (unitaires, fonctionnels, performance).
• Manuel d’installation et de déploiement.